"""
THE TREE CONSTRUCTOR (PARSER) TAKES A LIST OF TOKENS GENERATED BY THE TOKENIZER AND THEN,
CONVERTS IT INTO A CSS DOM OBJECT.
WHICH CAN THEN BE USED TO GENERATE THE RENDER TREE.
"""


class CSSParser:
    def __init__(self, stream):
        # TOKEN STREAM
        self.stream = stream

        # READ HEAD
        self.current_tok = {}
        self.next_tok = {}
        self.index = 0

        # STATE VARIABLES
        self.reconsuming = False
        self.top_level_flag = True

        # BUFFERS
        self.element_buffer = {}

    def consume(self, step=1):
        # UPDATE TOKENS
        if self.index < len(self.stream):
            if not self.reconsuming:
                # PUT NEXT TOKEN IN CURRENT TOKEN AND SET NEXT TOKEN AS THE ELEMENT AT THE CURRENT INDEX
                self.current_tok = self.next_tok
                self.next_tok = self.stream[self.index]
                # ONCE DONE UPDATING TOKENS MOVE AHEAD BY ONE
                self.index += step
            # RECONSUMING
            else:
                self.reconsuming = False
        else:
            if not self.reconsuming:
                self.current_tok = self.next_tok
                self.next_tok = {"token-type": "EOF-token"}
                self.index += step
            # RECONSUMING
            else:
                self.reconsuming = False
        return self.current_tok, self.next_tok

    def create_element(self, element_type):
        element_buffer = {
            "element-type": element_type
        }

        if element_type == "at-rule":
            element_buffer["name"] = ""
            element_buffer["prelude"] = []  # CONTAINS A LIST OF COMPONENT VALUES
            element_buffer["block"] = {}  # OPTIONAL, CONTAINS SIMPLE BLOCK
        elif element_type == "qualified-rule":
            element_buffer["prelude"] = []  # CONTAINS A LIST OF COMPONENT VALUES
            element_buffer["block"] = {}  # OPTIONAL, CONTAINS SIMPLE BLOCK
        elif element_type == "declaration":
            element_buffer["name"] = ""
            element_buffer["value"] = []  # CONTAINS A LIST OF COMPONENT VALUES
            element_buffer["important"] = "unset"

        self.element_buffer = element_buffer
        return element_buffer

    ####################################################################################
    # PARSER ALGORITHMS ################################################################
    def consume_list_of_rules(self):
        list_buffer = []

        while True:
            current_tok, next_tok = self.consume()
            if current_tok == {}:
                continue

            if current_tok["token-type"] == "whitespace-token":
                pass
            elif current_tok["token-type"] == "EOF-token":
                return list_buffer
            elif current_tok["token-type"] in ["CDO-token", "CDC-token"]:
                pass
            elif current_tok["token-type"] == "at-keyword-token":
                self.reconsuming = True
                list_buffer.append(self.consume_at_rule())
            else:
                self.reconsuming = True
                ret_val = self.consume_qualified_rule()
                if ret_val is not None:
                    list_buffer.append(ret_val)

    def consume_at_rule(self):
        current_tok, next_tok = self.consume()

        self.create_element("at-rule")
        self.element_buffer["name"] = current_tok["value"]

        while True:
            current_tok, next_tok = self.consume()

            if current_tok["token-type"] == "semicolon-token":
                return self.element_buffer
            elif current_tok["token-type"] == "EOF-token":
                # GENERATE PARSE ERROR
                return self.element_buffer
            elif current_tok["token-type"] == "{-token":
                self.element_buffer["block"] = self.consume_simple_block()
                return self.element_buffer
            # TODO: SKIPPED A CASE HERE BECAUSE I THINK IT'S IRRELEVANT HERE, CHECK SPECS
            else:
                self.reconsuming = True
                self.element_buffer["prelude"].append(self.consume_component_value())

    def consume_qualified_rule(self):
        self.create_element("qualified-rule")

        while True:
            current_tok, next_tok = self.consume()

            if current_tok["token-type"] == "EOF-token":
                # GENERATE PARSE ERROR
                return
            elif current_tok["token-type"] == "{-token":
                self.element_buffer["block"] = self.consume_simple_block()
                return self.element_buffer
            # TODO: SKIPPED A CASE HERE BECAUSE I THINK IT'S IRRELEVANT HERE, CHECK SPECS
            else:
                self.reconsuming = True
                self.element_buffer["prelude"].append(self.consume_component_value())

    def consume_list_of_declarations(self):
        pass

    def consume_declaration(self):
        pass

    def consume_component_value(self):
        current_tok, next_toke = self.consume()

        if current_tok["token-type"] in ["{-token", "[-token", "(-token"]:
            return self.consume_simple_block()
        elif current_tok["token-type"] == "function-token":
            return self.consume_function()
        else:
            return current_tok

    def consume_simple_block(self):
        mirror_variant = {"{": "}", "[": "]", "(": ")"}

        # example "[-token" will translate to "]-token"
        ending_tok = mirror_variant[self.current_tok["token-type"][0]] + "-token"

        simple_block = {
            "associated-token": self.current_tok["token-type"],
            "value": []
        }

        while True:
            current_tok, next_toke = self.consume()

            if current_tok["token-type"] == ending_tok:
                return simple_block
            elif current_tok["token-type"] == "EOF-token":
                # GENERATE PARSE ERROR
                return simple_block
            else:
                self.reconsuming = True
                simple_block["value"].append(self.consume_component_value())

    def consume_function(self):
        func_dict = {
            "name": self.current_tok["value"],
            "value": []
        }

        while True:
            current_tok, next_tok = self.consume()

            if current_tok["token-type"] == ")-token":
                return func_dict
            elif current_tok["token-type"] == "EOF-token":
                # GENERATE PARSE ERROR
                return func_dict
            else:
                self.reconsuming = True
                func_dict["value"].append(self.consume_component_value())

    ####################################################################################
    # PARSER EXPECTS A LIST OF TOKENS BUT FOR CONVENIENCE IT CAN ACCEPT OTHER INPUTS TOO
    def normalize_stream(self):
        pass

    ####################################################################################
    # PARSER ENTRY-POINTS ##############################################################
    def parse_stylesheet(self):
        self.normalize_stream()

        stylesheet = {
            "element-type": "stylesheet",
            "value": []
        }

        self.top_level_flag = True
        stylesheet["value"] = self.consume_list_of_rules()
        return stylesheet
